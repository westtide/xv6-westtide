# Bootasm.s

#### 1.寄存器布局:

<img src="/Users/xichao/Library/Application Support/typora-user-images/image-20210426155038207.png" alt="image-20210426155038207" style="zoom:30%;" />

```
lin8: %cs=0 %ip=7c00. 
```

\# %cs:代码段寄存器(Code Segment)

\# %ip:指令指针寄存器

8086启动的整体流程:

8086处理器在启动或者重启的时候，会对寄存器执行一个初始化的操作。初始化后的寄存器信息:
`CS：FF FF，其它的寄存器：00 00`。

启动重启计算机，寄存器被初始化

```
CS：FFFF IP：0000
```

FFFF0—> jmp F000：005C

```
CS：F000 IP：005C
```

F005C—>依次执行BIOS中的指令

BIOS所做的最后一件事：将主引导扇区中（0面0道1扇区，最后两个字节为硬盘主引导扇区的有效标志，必须为0x55，0xaa）的内容加载到7C00的位置处。

BIOS的最后一条指令：

```
JMP 0000：7C00
CS：0000 IP：7C00
```

07C00—>执行主引导扇区中的指令
1)加载操作系统自举代码到内存中
2)通过一条跳转指令，使处理器去执行操作系统的自举代码

[8086的启动过程_木子皿--啥都不会的菜鸟-CSDN博客](https://blog.csdn.net/SlowIsFastLemon/article/details/103756622)

#### 2.cli

lin16:

```
  cli                         # BIOS enabled interrupts; disable
```

Page 86 of 421: ***i386***

![截屏2021-04-26 16.15.03](/Users/xichao/Library/Application Support/typora-user-images/截屏2021-04-26 16.15.03.png)

#### 3.Lin27:inb     $0x64,%al

```
  inb     $0x64,%al               # Wait for not busy,0b1100100
```

[inb $0x64, %al的原理_Great_Enterprise的博客-CSDN博客](https://blog.csdn.net/Great_Enterprise/article/details/104063004)

其实就是在检查和写入 0x64， 0x60 这两个 port ，而前面的文章原文是这样说的：The last code block of boot1 enables access to memory above 1MBand concludes with a jump to the starting point of the BTX server。
也就是说，***上面除了 jmp 指令之外的代码，都是用来启用1MB以上的内存访问的。***

但是， 0x64 和 0x60 不是连着键盘控制器 的吗和内存有什么关系？
***A20地址线“A20” 用来指代第21位地址线（因为地址线是从零开始编号的）。***

这一位地址很特殊，在CPU启动之后默认总是0. 也就是说，即便CPU给地址总线发送的物理地址是 0x101234 ，第21位地址也会被置成零，从而寻址到 0x1234这个内存单元。
上面对 0x64 和 0x60 这两个 port 的操作，就是使 A20 地址线生效，不要总是发个零出去……

***至于 A20 为什么会被禁用，又为什么是用键盘控制器的 port 启用呢？***

这就要从PC诞生之初说起了……A20的历史在PC刚出现的时候，CPU只有一款，那就是8086 ,因为它和后续的 8088既便宜又耐操，所以很快流行起来。

这颗CPU有16位的寄存器，但是却有20条地址线 ，所以 Intel 发明了臭名昭著的用段寄存器访问更多内存的方法。

举个例子， abcd:1234 这个地址（16进制），冒号前面的是段寄存器的值，后面的是程序中访问的地址，那么真正的物理地址计算方法是0xabcd * 0x10 + 0x1234 = 0xacf04 . 这是个20位的地址，刚好可以用在8086的地址总线上。这个计算方式有个很微妙的问题： ffff:ffff 这个最大的地址映射到物理地址 0x10ffef ，TMD都超过20位了…… Intel 的解决方法是装作没看见第21位，将这个地址当作 0xffef 去访问……所以，当时的程序是可以通过访问 1MB 以上的地址，来获得物理地址 0xffef之前的数据的；也真有程序利用了这一点，从而省掉载入段寄存器的操作。

接下来 Intel 与时俱进推出了80286，它还是16位的CPU，但是地址总线一下子扩展到24位，所以CPU不能再对第21位地址视而不见了。

当新的程序访问ffff:ffff 这个地址时，它有可能是真的想访问物理地址 0x10ffef ；但是当旧的程序访问 ffff:ffff 时，它肯定是想要访问 0xffef .由于兼容旧程序是抢占市场的重要手段 ， Intel 决定让80286默认以8086一样的行为工作，也就是对第21位地址视而不见，总是将 A20 置为零。当程序确定它想要访问 1MB 以上的内存时，再通过特定的方式打开 A20.而这个特定的方式——不知道当时 Intel 那帮人怎么想的——就是用键盘控制器上多出来的一个状态位据说原因就是，有人发现那一位刚好多出来了，于是就出现了 boot loader 里捣鼓 0x64 和 0x60 这两个 port 的代码。

地址线比寄存器位数多是个传统；有人知道几乎所有的32位 x86 CPU都有36条地址线么……不过貌似64位的CPU还没到要遵守这个传统的时候XD这也是个传统，AMD大获成功的64位架构也是和32位x86兼容的A20的。未来A20的特殊性估计还会随着x86架构继续存在一段时间，因为虽然已经没有程序会通过 ffff:ffff 地址去访问 0xffef 了，但是几乎所有现代操作系统都会在启动阶段特意去启用A20.由于启用 A20 这个操作实在太恶心了，其实也有人想过别的方法，像是用其他的专用 port ，或是将启用 A20 的操作内置到 BIOS 中。可惜的是这些方法最后都没有被统一，操作系统们也只好用最古老、最保守的 0x64 、 0x60 port了。
一个小细节前面说 80286 有24条地址线，但它还是16位CPU，那怎么访问 ffff:ffff 之后的内存？这个地址换算成物理地址是 0x10ffef ，也就1MB多一点，最高3位的地址线 A21 、 A22 、 A23 不就没用了？没错，在“实模式”下，即使有24条地址线， 80286 也只能访问1MB多一点的内存。Intel 在 80286 身上想要挽回 8086 时期使用段寄存器寻址的错误，推出了“保护模式”，在保护模式下，CPU可以通过页表 将16位虚拟内存地址映射到24位物理地址，所以可以利用所有24位的地址空间。基本上所有现代操作系统都工作在保护模式或者与其相似的“长模式” 下，当CPU地址线增加的时候操作系统只需要更改页表的格式，而且对非法地址的访问会被作为异常处理掉，所以自 80286 以来再也没有出现过类似 A20 的问题。

#### 4.Load Global/Interrupt Descriptor Table (lgdt, lidt)

```
	  lgdt    gdtdesc
```

​		从真实模式切换到保护模式。使用引导GDT，使虚拟地址直接映射到物理地址，以便有效的内存映射在转换过程中不会改变。

​		GDT:Global Descriptor Table

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/0/0a/SegmentDescriptor.svg/640px-SegmentDescriptor.svg.png?1619431368639)	

